问题描述：
    有这样一群鸭子，有这样几种行为：飞、叫、游泳、外观。
    然而不同类型的鸭子有不同的行为，比如有的鸭子会飞，有的鸭子不会飞，有的鸭子是呱呱叫，有的鸭子是吱吱叫，有的鸭子不叫。游泳和外观变化不大。
    如果鸭子的种类在不断的增多，为了代码的复用性，减少代码的重复性。该如何设计？

    接口和继承的思想。
    Duck类为所有鸭子的父类。里面有swim()，fly(),quack(),display().

设计原则：
1、找出应用中可能需要变化之处，把它们独立出来，“封装”起来，好让其他部分不受影响。即，系统中某部分的改变不会影响其他部分。

    由于fly和quack会经常变化，那么建立两组类，一个是fly相关，一个是quack相关，每一组类实现各自的动作，
比如，有一个实现类是“呱呱叫”，另一个实现类是“吱吱叫”，还有一个实现类实现安静。然后将这两个犯法从Duck类中移除。

    然后由每个鸭子实现Duck类与某一个飞行的实现类和某一个quack的实现类。

    但是，我们希望一切皆有弹性，我们还想能够“指定”行为到鸭子的实例，比方说，我们想要产生一个新的绿头鸭实例，并指定特定“类型”的飞行行为给它，那干脆顺便让鸭子的行为可以动态改变、
    换句话说，我们应该在鸭子类中包含设定行为的方法，这样就可以在“运行时”动态的“改变”绿头鸭的飞行行为。

2、针对接口编程，而不是针对实现编程。

    我们利用接口代表每个行为，比方说，FlyBehavior与QuackBehavior，而行为的每个实现都将实现其中一个接口。
    所以鸭子类不会负责实现Flying与Quacking接口，反而是由我们制造一组其他类专门实现FlyBehavior与QuackBehavior。这就成为“行为”类。由行为类而不是Duck类来实现行为接口。

    这样的做法不同以往，以前的做法是：行为来自Duck超类的具体实现，或是继承某个接口并由子类自行实现。这两种做法都是依赖于“实现”，我们被“实现”绑的死死的，没法更改行为。

    在新设计中，鸭子的子类将使用接口（FlyBehavior与QuackBehavior）所表示的行为，所以，实际的“实现”不会被绑死在鸭子的子类中。（换句话说，特定的具体行为编写在实现了FlyBehavior与QuackBehavior的类中）。

    FlyBehavior ---> FlyWithWings(实现鸭子的飞行动作)、FlyNoWay(什么都不做，不会飞)

    “针对超类型编程”这句话，可以更明确的说成“变量的声明类型应该是超类型，通常是一个抽象类或一个接口”。如此，只要是具体实现此超类型的类所产生的对象，都可以指定给这个变量。
声明类时不用理会以后执行时的真正对象类型。

实现鸭子的行为，见代码。FlyNoWay、FlyWithWings、MuteQuack、Quack、Squack

    这样可以让飞行和呱呱叫的动作被其他的对象复用，因为这些行为已经与鸭子类无关了。
    而我们可以新增一些行为，不会影响到既有的行为类，也不会影响“使用”到飞行行为的鸭子类。

整合鸭子的行为：
    关键在于，现在鸭子会将飞行和呱呱叫的行为“委托”别人处理，而不是使用定义在Duck类（或子类内）的呱呱叫和飞行方法。
    做法：
    1.首先在Duck类中“加入两个实例变量”，分别为：“flyBehavior”与“quackBehavior”，声明为接口类型，而不是某一实现类类型，每个鸭子对象都会动态的设置这些变量以为运行时引用正确的行为类型。
    2.用两个相似于fly和quack的方法performFly()和performQuack().
    代码见Duck.

    public MallardDuck(){
        quackBehavior = new Quack();//将叫的职责委托给quack对象
        flyBehavior = new FlyWithWings();
    }
    这种方式，属于在构造器里制造一个具体的实现类的实例。后面，使用动态设定行为的方式。

    在Duck类中加入两个setter方法，在运行时想改变鸭子的行为，只需调用鸭子的setter方法即可。

    把每组行为想象成一个“算法族”，那些实现行为即为算法，这些算法是可以互换的。

3、多用组合，少用继承。HAS-A可能比IS-A更好。

以上，是使用了策略模式（Strategy Pattern）。
策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。


